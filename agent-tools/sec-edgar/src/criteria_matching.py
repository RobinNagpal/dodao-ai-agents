# Purpose:
#     This lambda will be called to extract data related to few topics from the reports.
#     Parameters like - rent, lease, debt, stock distribution

# There will be a function which will get the latest 10Q report from the SEC and all the attachments from the report.
# For each attachment(ignore balance_sheet, ic, cf), the function will call chatgpt 4o-mini to see if know if the attachments has data specific to
# the topic. At a time max 2 topics can match. The output will a json
# {
#    "topic_rent": {matched: true, match_confidence: 0.8},
#    "topic_debt": {matched: true, match_confidence: 0.8},
#  }

# We can keep a status file at the top to see if the process is completed or not.

# We can probably collect all this information and for each topic pick the top 10(or less) and store it in a file in s3 bucket.

# we create a file related to each topic in s3 bucket and store the attachments in the file.
#  So the path will be <ProjectTicker>/Latest10QReport/<TopicName>.txt
#  So the path will be FVR/Latest10QReport/rent.txt
#  So the path will be FVR/Latest10QReport/debt.txt

# We need to see how lambda executes in the background, as we want to say that it has started processing, and the
# lambda should die only after processing and collecting information for each topic.

# There can be another tool which can just read the file and return it to the agent for analysis. And the tool can
# throw an error if the file is not present.

import json
import boto3
import os
from edgar import *
from langchain_core.messages import HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI
from typing import Optional, Literal, List, Union, TypedDict
from pydantic import BaseModel, Field
from dotenv import load_dotenv
from public_equity_structures import IndustryGroupCriteria, CriterionMatchesOfLatest10Q, get_criteria_file_key, \
    TickerReport, CriterionMatch, get_ticker_file_key, Sector, IndustryGroup, IndustryGroupCriterion, \
    SecFilingAttachment
from collections import defaultdict

load_dotenv()

s3_client = boto3.client("s3")
S3_BUCKET_NAME = os.getenv("S3_BUCKET_NAME")


class TickersInfoAndAttachments(TypedDict):
    cik: str
    acc_number_no_dashes: str
    attachments: List[Attachment]


reit_criteria: IndustryGroupCriteria = {
    "tickers": [
        "O",
        "SPG",
        "PLD",
        "PSA",
        "VTR",
        "AVB",
        "EQR",
        "ESS"
    ],
    "selectedIndustryGroup": {
        "id": 6010,
        "name": "Equity Real Estate Investment Trusts (REITs)"
    },
    "selectedSector": {
        "id": 60,
        "name": "Real Estate"
    },
    "criteria": [
        {
            "key": "financial_performance",
            "name": "Financial Performance",
            "shortDescription": "Evaluates the company's financial health and profitability.",
            "importantMetrics": [
                {
                    "key": "revenue_growth",
                    "name": "Revenue Growth",
                    "description": "Measures the increase in a company's sales over a specific period.",
                    "formula": "(current_period_revenue - previous_period_revenue) / previous_period_revenue"
                },
                {
                    "key": "net_income_margin",
                    "name": "Net Income Margin",
                    "description": "Indicates how much profit a company makes for every dollar of revenue.",
                    "formula": "net_income / total_revenue"
                },
                {
                    "key": "funds_from_operations",
                    "name": "Funds from Operations (FFO)",
                    "description": "A key performance indicator for REITs, reflecting cash generated by operations.",
                    "formula": "net_income + depreciation + amortization - gains on sales"
                }
            ],
            "reports": [
                {
                    "key": "financial_summary",
                    "name": "Financial Summary Report",
                    "description": "Provides a comprehensive overview of the company's financial performance, including revenue growth, net income margin, and FFO.",
                    "outputType": "Text"
                }
            ]
        },
        {
            "key": "market_positioning",
            "name": "Market Positioning",
            "shortDescription": "Assesses the company's competitive position within the real estate market.",
            "importantMetrics": [
                {
                    "key": "market_share",
                    "name": "Market Share",
                    "description": "Represents the company's portion of the total market sales.",
                    "formula": "company_sales / total_market_sales"
                },
                {
                    "key": "tenant_diversification",
                    "name": "Tenant Diversification",
                    "description": "Evaluates the diversity of the tenant base to mitigate risk.",
                    "formula": "number_of_unique_tenants / total_tenants"
                },
                {
                    "key": "geographic_diversification",
                    "name": "Geographic Diversification",
                    "description": "Assesses the spread of properties across different regions to reduce location-specific risks.",
                    "formula": "number_of_regions / total_properties"
                }
            ],
            "reports": [
                {
                    "key": "market_position_report",
                    "name": "Market Position Report",
                    "description": "Analyzes the company's market share, tenant, and geographic diversification to determine its competitive standing.",
                    "outputType": "BarGraph"
                }
            ]
        },
        {
            "key": "operational_efficiency",
            "name": "Operational Efficiency",
            "shortDescription": "Measures how effectively the company manages its operations and resources.",
            "importantMetrics": [
                {
                    "key": "occupancy_rate",
                    "name": "Occupancy Rate",
                    "description": "Indicates the percentage of rented or used space compared to the total available space.",
                    "formula": "occupied_units / total_units"
                },
                {
                    "key": "property_management_costs",
                    "name": "Property Management Costs",
                    "description": "Evaluates the expenses associated with managing properties.",
                    "formula": "total_management_expenses / total_revenue"
                },
                {
                    "key": "lease_renewal_rate",
                    "name": "Lease Renewal Rate",
                    "description": "Measures the percentage of leases renewed at the end of their term.",
                    "formula": "number_of_renewed_leases / total_leases"
                }
            ],
            "reports": [
                {
                    "key": "operational_efficiency_report",
                    "name": "Operational Efficiency Report",
                    "description": "Examines occupancy rates, property management costs, and lease renewal rates to assess operational effectiveness.",
                    "outputType": "PieChart"
                }
            ]
        },
        {
            "key": "rental_income_analysis",
            "name": "Rental Income Analysis",
            "shortDescription": "Focuses on the company's ability to generate rental income from its properties.",
            "importantMetrics": [
                {
                    "key": "average_rent_per_square_foot",
                    "name": "Average Rent per Square Foot",
                    "description": "Calculates the average rental income per square foot of property.",
                    "formula": "total_rental_income / total_square_footage"
                },
                {
                    "key": "rental_income_growth",
                    "name": "Rental Income Growth",
                    "description": "Tracks the increase in rental income over time.",
                    "formula": "(current_period_rental_income - previous_period_rental_income) / previous_period_rental_income"
                },
                {
                    "key": "rent_collection_rate",
                    "name": "Rent Collection Rate",
                    "description": "Measures the efficiency of rent collection from tenants.",
                    "formula": "collected_rent / total_rent_due"
                }
            ],
            "reports": [
                {
                    "key": "rental_income_report",
                    "name": "Rental Income Report",
                    "description": "Provides insights into average rent per square foot, rental income growth, and rent collection efficiency.",
                    "outputType": "Text"
                }
            ]
        }
    ]
}

class AttachmentWithContent(SecFilingAttachment):
    attachmentContent: str

class AttachmentsByCriterion(TypedDict):
    criterion_key: str
    attachments: List[Attachment]


class CriterionMatchItem(BaseModel):
    """Criterion match item"""

    criterion_key: str = Field(description="The key of the matched criterion")
    matched: bool = Field(description="Whether the criterion matched")
    matched_amount: float = Field(
        description="The percentage of the content that matched the keyword"
    )


class CriterionMatchResponse(BaseModel):
    """Return LLM response in a structured format"""

    criterion_matches: List[CriterionMatchItem] = Field(
        description="List of criterion matches"
    )
    status: Literal["success", "failure"] = Field(
        description="If successful in processing the prompt and producing the output."
    )
    failureReason: Optional[str] = Field(
        description="The reason for the failure if the status is failed."
    )


def get_object_from_s3(key: str) -> dict:
    s3_obj = s3_client.get_object(Bucket=S3_BUCKET_NAME, Key=key)
    body = s3_obj["Body"].read().decode("utf-8")
    data = json.loads(body)
    return data


def get_criteria(sector_name: str, industry_group_name: str) -> IndustryGroupCriteria:
    key = get_criteria_file_key(sector_name, industry_group_name)
    data = get_object_from_s3(key)
    return IndustryGroupCriteria(**data)


def get_ticker_report(ticker: str) -> TickerReport:
    key = get_ticker_file_key(ticker)
    data = get_object_from_s3(key)
    return TickerReport(**data)


def put_ticker_report_to_s3(ticker: str, report: TickerReport):
    """Writes the updated info JSON to S3."""
    key = get_ticker_file_key(ticker)
    data = json.dumps(report, indent=2)
    s3_client.put_object(
        Bucket=S3_BUCKET_NAME,
        Key=key,
        Body=data.encode("utf-8"),
        ContentType="application/json",
    )


def create_criteria_match_analysis(
        attachment_name: str,
        attachment_content: str,
        criteria: List[IndustryGroupCriterion]
) -> CriterionMatchResponse:
    """
    Calls GPT-4o-mini to analyze if the content is relevant to provided topics.
    """

    criteria_json = json.dumps(
        [{"key": kw.get('key'), "name": kw.get('name'), "shortDescription": kw.get('shortDescription')
          } for kw in criteria], indent=2)

    prompt = f"""
    You are analyzing a section from an SEC 10-Q filing named '{attachment_name}'.
    Determine how relevant the section is to each of the following criteria.

    ### **Importance of Precision**
        - We are collecting only **highly relevant** sections, as they will later be analyzed for financial ratios and investment insights.
        - **Loose or partial relevance is NOT enough**—a section should match **only if it contains direct, substantial information** about a topic.
        - A section **must be strongly and directly related** to the topic to be considered a match.

    For each criterion, output:
    - 'matched': true or false
    - 'matched_amount': a percentage (0-100) indicating how much of the section is directly relevant
    (Only return true if more than 60% is genuinely relevant).
    - You can match at most two criteria as 'true'.

    Return JSON that fits the EXACT structure of 'CriterionMatchResponse':
    {{
    "criterion_matches": [
        {{
        "criterion_key": "...",
        "matched": true/false,
        "matched_amount": 0-100
        }},
        ...
    ],
    "status": "success" or "failure",
    "confidence": 1-10,
    "failureReason": "optional"
    }}

    Criteria:
    {criteria_json}

    ATTACHMENT CONTENT:
    {attachment_content}
    """

    model = ChatOpenAI(model="gpt-4o-mini", temperature=0)
    structured_llm = model.with_structured_output(CriterionMatchResponse)
    response: CriterionMatchResponse = structured_llm.invoke(
        [HumanMessage(content=prompt)]
    )
    return response


def get_ticker_info_and_attachments(ticker: str) -> TickersInfoAndAttachments:
    set_identity("dodao@gmail.com")
    company = Company(ticker)
    filings = company.get_filings(form="10-Q")

    if not filings:
        raise Exception(f"Error: No 10-Q filings found for {ticker}.")

    latest_10q = filings.latest()
    cik = latest_10q.cik
    raw_acc_number = latest_10q.accession_number  # e.g. "0000950170-24-127114"
    acc_number_no_dashes = raw_acc_number.replace("-", "")

    attachments = latest_10q.attachments

    return {
        "cik": cik,
        "acc_number_no_dashes": acc_number_no_dashes,
        "attachments": attachments,
    }



def get_matched_attachments(
        ticker: str,
        criteria: List[IndustryGroupCriterion]
) -> CriterionMatchesOfLatest10Q:
    """
    Fetches the latest 10-Q filing, extracts attachments, analyzes content, and stores results.
    """

    attachments_by_criterion_map = defaultdict(list[AttachmentWithContent])
    for criterion in criteria:
        print(f"Keywords: {criterion.get('shortDescription')}")

        ticker_info = get_ticker_info_and_attachments(ticker)
        cik = ticker_info.get("cik")
        acc_number_no_dashes = ticker_info.get("acc_number_no_dashes")
        attachments = ticker_info.get("attachments")

        excluded_purposes = [
            "cover",
            "balance sheet",
            "statements of cash flows",
            "statement of cash flows",
            "statements of comprehensive income",
            "statements of operations and comprehensive income",
            "statement of operations and comprehensive income",
            "statements of operations",
            "statements of equity",
        ]



        for attach in attachments:
            if attach.document_type != "HTML":
                continue

            attachment_purpose = str(attach.purpose or "").lower()
            attachment_document_name = str(attach.document or "")  # e.g. "R10.htm"
            attachment_sequence_number: str = attach.sequence_number  # e.g. "R10.htm"
            attachment_content = str(attach.text() or "")
            attachment_url = f"https://www.sec.gov/Archives/edgar/data/{cik}/{acc_number_no_dashes}/{attachment_document_name}"

            print(f"Processing attachment: {attachment_sequence_number} - {attachment_document_name} - {attachment_purpose} - {attachment_url}")
            # Skipping conditions
            if any(excluded in attachment_purpose for excluded in excluded_purposes):
                continue

            if not attachment_purpose:
                print(f"Warning: Attachment {attach.purpose} has empty purpose; skipping.")
                continue
            if not attachment_document_name:
                print(f"Warning: Attachment {attach.purpose} has empty filename; skipping.")
                continue
            if not attachment_content:
                print(f"Warning: Attachment {attach.purpose} has empty content; skipping.")
                continue

            match_analysis = create_criteria_match_analysis(
                attachment_name=attachment_purpose,
                attachment_content=attachment_content,
                criteria=criteria
            )

            if match_analysis and match_analysis.status == "failure":
                raise Exception(f"Error: LLM analysis failed for attachment {attachment_document_name}.")



            for item in match_analysis.criterion_matches:
                if item.matched:
                    attachments_by_criterion_map[item.criterion_key].append(
                        AttachmentWithContent(
                            attachmentSequenceNumber=attachment_sequence_number,
                            attachmentDocumentName=attachment_document_name,
                            attachmentPurpose=attachment_purpose,
                            attachmentUrl=attachment_url,
                            attachmentContent=attachment_content,
                            matchedPercentage=item.matched_amount,
                        )
                    )

    criterion_to_matched_attachments: List[CriterionMatch] = []
    for c_key, matched_list in attachments_by_criterion_map.items():
        top_attachments = sorted(
            matched_list,
            key=lambda x: x.matched_amount,
            reverse=True,
        )[:5]

        refined_texts = [
            filter_text_to_latest_quarter(attachment.content) for attachment in top_attachments
        ]

        criterion_to_matched_attachments.append(
            CriterionMatch(criterionKey=c_key, matchedAttachments=matched_list, matchedContent="\n\n".join(refined_texts))
        )

    return CriterionMatchesOfLatest10Q(criterionMatches=criterion_to_matched_attachments, status="Completed")


# TODO: This prompt should be generic. Right now its a bit specific like “3 months ended” vs “9 months ended,” or “Sep. 30, 2024” vs “Dec. 31, 2023”
def filter_text_to_latest_quarter(raw_text: str) -> str:
    """
    Calls GPT-4o-mini to filter out older periods and keep only
    the latest quarter. Preserves original formatting.
    """
    llm = ChatOpenAI(
        temperature=0,
        model="gpt-4o-mini",
    )

    system_prompt = """
    You are a financial data extraction assistant. The user has provided some
    text from a 10-Q attachment. It may contain multiple time periods
    (e.g. “3 months ended” vs “9 months ended,” or “Sep. 30, 2024” vs “Dec. 31, 2023”).

    Your job:
    1) Remove any older periods/columns, retaining only the latest quarter or period.
    2) Preserve the rest of the text exactly as it is, including spacing and line breaks,
    except for the removed columns/rows.
    3) Do not reformat or summarize; do not alter numbers or wording.
    4) If there is only one set of data, keep it entirely.
    5) Preserve all headings and subheadings as lines above the table.
    6) Return the final data in Markdown tabular format.
    """

    user_prompt = f"""
    Here is the raw financial statement text from one 10-Q attachment.
    Please remove older periods but keep the latest quarter/period.

    Raw text:
    {raw_text}
    """

    response = llm.invoke(
        [SystemMessage(content=system_prompt), HumanMessage(content=user_prompt)]
    )

    return response.content

def populate_criteria_matches(ticker: str):
    report: TickerReport = get_ticker_report(ticker)
    try:
        sector: Sector = report.get('selectedSector')
        industry_group: IndustryGroup = report.get('selectedIndustryGroup')
        industry_group_criteria = get_criteria(sector.get('name'), industry_group.get('name'))
        criteria: List[IndustryGroupCriterion] = industry_group_criteria.get('criteria')
        criteria_matches = get_matched_attachments(ticker, criteria)
        report['criteriaMatchesOfLatest10Q'] = criteria_matches
        put_ticker_report_to_s3(ticker, report)
    except Exception as e:
        print(f"Error: {str(e)}")
        criteria_matches = CriterionMatchesOfLatest10Q(criterionMatches=[], status="Failed", failureReason=str(e))
        report['criteriaMatchesOfLatest10Q'] = criteria_matches
        put_ticker_report_to_s3(ticker, report)
        raise e


def get_criterion_attachments_content(
        ticker: str,
        criterion_key: str
) -> str:
    """
    This function:
      - Retrieves existing data from S3.
      - Extracts and processes the top 5 matched attachments.
      - Calls GPT-4o-mini to keep only the latest quarter's content.
      - If data is missing, runs the full process and then returns results.
    """
    public_equity_report: TickerReport = get_ticker_report(ticker)
    criteria_matches: Optional[CriterionMatchesOfLatest10Q] = public_equity_report.get("criteriaMatchesOfLatest10Q")
    if criteria_matches is None:
        raise Exception(f"Error: No criterion matches found for {ticker}.")
    if criteria_matches.get("status") != "Completed":
        raise Exception(f"Error: Criterion match process failed for {ticker}.")


    matches: List[CriterionMatch] = criteria_matches.get('criterionMatches', [])
    if not matches:
        raise Exception(f"No matches available for criterion key: {criterion_key}.")

    criterion_match = next(
        (cm for cm in matches if cm.get('criterionKey') == criterion_key), None
    )

    if criterion_match is None:
        raise Exception(f"Error: No criterion match found for {criterion_key}.")

    return criterion_match.get("matchedContent")
